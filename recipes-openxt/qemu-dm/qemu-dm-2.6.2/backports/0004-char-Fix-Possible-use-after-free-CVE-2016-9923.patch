From 1efe49dc46c03930a3cbf9d31b310bb8dab1ed42 Mon Sep 17 00:00:00 2001
From: Jason Andryuk <jandryuk@gmail.com>
Date: Fri, 22 Jun 2018 15:41:10 -0400
Subject: [PATCH 04/39] char: Fix Possible use-after-free (CVE-2016-9923)

From the CVE:
Quick Emulator (Qemu) built with the 'chardev' backend support is
vulnerable to a use after free issue. It could occur while hotplug and
unplugging the device in the guest. A guest user/process could use this
flaw to crash a Qemu process on the host resulting in DoS.

The upstream fix incorporates other code changes, but the relevant
portion is pointed out by Paolo Bonzini in this email:

https://lists.gnu.org/archive/html/qemu-devel/2016-10/msg05597.html

Upstream commit a4afa548fc6dd9842ed86639b4d37d4d1c4ad480

The upstream commit also mentions
    Also a mux CharDriver should go through mux->backends[focused], since
    chr->be will stay NULL. Before that, it was possible to call
    chr->handler by mistake with surprising results, for ex through
    qemu_chr_be_can_write(), which would result in calling the last set
    handler front end, not the one with focus.

This is not fixed.

Signed-off-by: Jason Andryuk <jandryuk@gmail.com>

CVE-2016-9923
---
 qemu-char.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/qemu-char.c b/qemu-char.c
index 05d602bba8..a2e166c984 100644
--- a/qemu-char.c
+++ b/qemu-char.c
@@ -4542,6 +4542,17 @@ out_error:
     return NULL;
 }
 
+static bool qemu_chr_is_busy(CharDriverState *chr)
+{
+    if (chr->is_mux) {
+        MuxDriver *d = chr->opaque;
+        return d->mux_cnt >= 0;
+    } else {
+        return (chr->chr_can_read || chr->chr_read ||
+                chr->chr_event || chr->handler_opaque);
+    }
+}
+
 void qmp_chardev_remove(const char *id, Error **errp)
 {
     CharDriverState *chr;
@@ -4551,8 +4562,7 @@ void qmp_chardev_remove(const char *id, Error **errp)
         error_setg(errp, "Chardev '%s' not found", id);
         return;
     }
-    if (chr->chr_can_read || chr->chr_read ||
-        chr->chr_event || chr->handler_opaque) {
+    if (qemu_chr_is_busy(chr)) {
         error_setg(errp, "Chardev '%s' is busy", id);
         return;
     }
-- 
2.17.0

